<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒœãƒ³ãƒãƒ¼ãƒãƒˆãƒ«</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Hiragino Sans', 'Hiragino Kaku Gothic Pro', 'Yu Gothic', 'Meiryo', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: white;
        }

        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #gameCanvas {
            border: 3px solid white;
            border-radius: 10px;
            background: #2c3e50;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .game-info {
            margin: 20px 0;
            display: flex;
            justify-content: space-between;
            font-size: 1.2em;
            font-weight: bold;
        }

        .controls {
            margin-top: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        .controls h3 {
            margin-top: 0;
            color: #ffeb3b;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        .restart-btn {
            margin-top: 20px;
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background 0.3s;
        }

        .restart-btn:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ’£ ãƒœãƒ³ãƒãƒ¼ãƒãƒˆãƒ«</h1>
        <div class="game-info">
            <span>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼: <span id="playerHealth">â¤ï¸â¤ï¸â¤ï¸</span></span>
            <span>ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿: <span id="aiHealth">â¤ï¸â¤ï¸â¤ï¸</span></span>
        </div>
        <canvas id="gameCanvas" width="600" height="600"></canvas>
        <div class="controls">
            <h3>æ“ä½œæ–¹æ³•</h3>
            <div class="control-row">
                <span><strong>ç§»å‹•:</strong> â†‘â†“â†â†’ ã‚­ãƒ¼</span>
                <span><strong>çˆ†å¼¾è¨­ç½®:</strong> ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼</span>
            </div>
            <div style="margin-top: 15px;">
                <strong>ã‚²ãƒ¼ãƒ é–‹å§‹:</strong> Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„
            </div>
        </div>
        <div class="controls">
            <h3>ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ«</h3>
            <div style="font-size: 1em; line-height: 1.5;">
                ãƒ» çˆ†å¼¾ã¯5ç§’å¾Œã«çˆ†ç™ºã—ã¾ã™<br>
                ãƒ» çˆ†ç™ºç¯„å›²ã¯ä¸Šä¸‹å·¦å³3ãƒ–ãƒ­ãƒƒã‚¯<br>
                ãƒ» ãƒ–ãƒ­ãƒƒã‚¯ã®å½±ã«éš ã‚Œã¦çˆ†ç™ºã‚’å›é¿ã—ã‚ˆã†<br>
                ãƒ» ç›¸æ‰‹ã‚’3å›çˆ†ç™ºã«å·»ãè¾¼ã‚€ã¨å‹åˆ©
            </div>
        </div>
        <div class="game-over" id="gameOver">
            <h2 id="winnerText"></h2>
            <button class="restart-btn" onclick="restartGame()">å†ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ã‚²ãƒ¼ãƒ è¨­å®š
        const GRID_SIZE = 30;
        const COLS = canvas.width / GRID_SIZE;
        const ROWS = canvas.height / GRID_SIZE;

        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        let gameState = {
            isPlaying: false,
            playerHealth: 3,
            aiHealth: 3,
            bombs: [],
            explosions: []
        };

        // ãƒãƒƒãƒ— (0: ç©º, 1: å›ºå®šå£, 2: ç ´å£Šå¯èƒ½å£)
        let gameMap = [];

        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
        const player = {
            x: 1,
            y: 1,
            color: '#3498db'
        };

        // AI
        const ai = {
            x: COLS - 2,
            y: ROWS - 2,
            color: '#e74c3c',
            lastMoveTime: 0,
            target: null
        };
        
        // ç§»å‹•ã‚¹ãƒ”ãƒ¼ãƒ‰åˆ¶å¾¡
        let playerLastMoveTime = 0;
        const MOVE_DELAY = 200; // 200msã”ã¨ã«ç§»å‹•å¯èƒ½

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
        const keys = {};

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'Enter') {
                if (!gameState.isPlaying) {
                    startGame();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function initializeMap() {
            gameMap = [];
            for (let y = 0; y < ROWS; y++) {
                gameMap[y] = [];
                for (let x = 0; x < COLS; x++) {
                    if (x === 0 || x === COLS - 1 || y === 0 || y === ROWS - 1) {
                        gameMap[y][x] = 1; // å¤–å£
                    } else if (x % 2 === 0 && y % 2 === 0) {
                        gameMap[y][x] = 1; // å›ºå®šãƒ–ãƒ­ãƒƒã‚¯
                    } else if ((x === 1 && y === 1) || (x === 2 && y === 1) || (x === 1 && y === 2) ||
                               (x === COLS - 2 && y === ROWS - 2) || (x === COLS - 3 && y === ROWS - 2) || (x === COLS - 2 && y === ROWS - 3)) {
                        gameMap[y][x] = 0; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ»AIå‘¨è¾ºã¯ç©º
                    } else if (Math.random() < 0.3) {
                        gameMap[y][x] = 2; // ç ´å£Šå¯èƒ½å£
                    } else {
                        gameMap[y][x] = 0; // ç©º
                    }
                }
            }
        }

        function startGame() {
            gameState.isPlaying = true;
            gameState.playerHealth = 3;
            gameState.aiHealth = 3;
            gameState.bombs = [];
            gameState.explosions = [];
            
            player.x = 1;
            player.y = 1;
            ai.x = COLS - 2;
            ai.y = ROWS - 2;
            
            initializeMap();
            updateHealthDisplay();
            document.getElementById('gameOver').style.display = 'none';
            gameLoop();
        }

        function updateHealthDisplay() {
            document.getElementById('playerHealth').textContent = 'â¤ï¸'.repeat(gameState.playerHealth);
            document.getElementById('aiHealth').textContent = 'â¤ï¸'.repeat(gameState.aiHealth);
        }

        function canMoveTo(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
            return gameMap[y][x] === 0;
        }

        function updatePlayer() {
            const currentTime = Date.now();
            
            // ç§»å‹•ã‚¹ãƒ”ãƒ¼ãƒ‰åˆ¶å¾¡
            if (currentTime - playerLastMoveTime < MOVE_DELAY) return;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
            let moved = false;
            if (keys['ArrowUp'] && canMoveTo(player.x, player.y - 1)) {
                player.y--;
                moved = true;
            }
            if (keys['ArrowDown'] && canMoveTo(player.x, player.y + 1)) {
                player.y++;
                moved = true;
            }
            if (keys['ArrowLeft'] && canMoveTo(player.x - 1, player.y)) {
                player.x--;
                moved = true;
            }
            if (keys['ArrowRight'] && canMoveTo(player.x + 1, player.y)) {
                player.x++;
                moved = true;
            }
            
            if (moved) {
                playerLastMoveTime = currentTime;
            }

            // çˆ†å¼¾è¨­ç½®
            if (keys[' ']) {
                placeBomb(player.x, player.y, 'player');
                keys[' '] = false; // é€£ç¶šè¨­ç½®é˜²æ­¢
            }
        }

        function updateAI() {
            const currentTime = Date.now();
            
            // 0.8ç§’ã”ã¨ã«è¡Œå‹•ï¼ˆã‚ˆã‚Šã‚†ã£ãã‚Šï¼‰
            if (currentTime - ai.lastMoveTime < 800) return;
            ai.lastMoveTime = currentTime;

            // å±é™ºã‚¨ãƒªã‚¢ã‚’ãƒã‚§ãƒƒã‚¯
            const dangerZones = getDangerZones();
            const aiInDanger = dangerZones.some(zone => zone.x === ai.x && zone.y === ai.y);

            if (aiInDanger) {
                // é€ƒã’ã‚‹
                const safeMoves = getSafeMoves(ai.x, ai.y, dangerZones);
                if (safeMoves.length > 0) {
                    const move = safeMoves[Math.floor(Math.random() * safeMoves.length)];
                    ai.x = move.x;
                    ai.y = move.y;
                }
            } else {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿‘ã¥ãã‹çˆ†å¼¾ã‚’è¨­ç½®
                const distanceToPlayer = Math.abs(ai.x - player.x) + Math.abs(ai.y - player.y);
                
                if (distanceToPlayer <= 4 && Math.random() < 0.3) {
                    // çˆ†å¼¾è¨­ç½®
                    placeBomb(ai.x, ai.y, 'ai');
                } else {
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
                    moveAITowardsPlayer();
                }
            }
        }

        function getDangerZones() {
            const zones = [];
            gameState.bombs.forEach(bomb => {
                // çˆ†å¼¾ã®ä½ç½®
                zones.push({x: bomb.x, y: bomb.y});
                
                // ä¸Šä¸‹å·¦å³3ãƒ–ãƒ­ãƒƒã‚¯
                for (let i = 1; i <= 3; i++) {
                    if (canExplosionReach(bomb.x, bomb.y - i)) zones.push({x: bomb.x, y: bomb.y - i});
                    if (canExplosionReach(bomb.x, bomb.y + i)) zones.push({x: bomb.x, y: bomb.y + i});
                    if (canExplosionReach(bomb.x - i, bomb.y)) zones.push({x: bomb.x - i, y: bomb.y});
                    if (canExplosionReach(bomb.x + i, bomb.y)) zones.push({x: bomb.x + i, y: bomb.y});
                }
            });
            return zones;
        }

        function canExplosionReach(x, y) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return false;
            return gameMap[y][x] !== 1; // å›ºå®šå£ã§ãƒ–ãƒ­ãƒƒã‚¯
        }

        function getSafeMoves(x, y, dangerZones) {
            const moves = [];
            const directions = [{x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}];
            
            directions.forEach(dir => {
                const newX = x + dir.x;
                const newY = y + dir.y;
                if (canMoveTo(newX, newY)) {
                    const isDangerous = dangerZones.some(zone => zone.x === newX && zone.y === newY);
                    if (!isDangerous) {
                        moves.push({x: newX, y: newY});
                    }
                }
            });
            
            return moves;
        }

        function moveAITowardsPlayer() {
            const directions = [];
            
            if (ai.x < player.x && canMoveTo(ai.x + 1, ai.y)) {
                directions.push({x: ai.x + 1, y: ai.y});
            }
            if (ai.x > player.x && canMoveTo(ai.x - 1, ai.y)) {
                directions.push({x: ai.x - 1, y: ai.y});
            }
            if (ai.y < player.y && canMoveTo(ai.x, ai.y + 1)) {
                directions.push({x: ai.x, y: ai.y + 1});
            }
            if (ai.y > player.y && canMoveTo(ai.x, ai.y - 1)) {
                directions.push({x: ai.x, y: ai.y - 1});
            }
            
            if (directions.length > 0) {
                const move = directions[Math.floor(Math.random() * directions.length)];
                ai.x = move.x;
                ai.y = move.y;
            }
        }

        function placeBomb(x, y, owner) {
            // æ—¢ã«çˆ†å¼¾ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
            const existingBomb = gameState.bombs.find(bomb => bomb.x === x && bomb.y === y);
            if (existingBomb) return;

            gameState.bombs.push({
                x: x,
                y: y,
                owner: owner,
                timer: 5000, // 5ç§’
                startTime: Date.now()
            });
        }

        function updateBombs() {
            const currentTime = Date.now();
            
            for (let i = gameState.bombs.length - 1; i >= 0; i--) {
                const bomb = gameState.bombs[i];
                const elapsed = currentTime - bomb.startTime;
                
                if (elapsed >= bomb.timer) {
                    // çˆ†ç™º
                    explodeBomb(bomb);
                    gameState.bombs.splice(i, 1);
                }
            }
        }

        function explodeBomb(bomb) {
            const explosionCells = [];
            
            // çˆ†å¼¾ã®ä½ç½®
            explosionCells.push({x: bomb.x, y: bomb.y});
            
            // ä¸Šä¸‹å·¦å³3ãƒ–ãƒ­ãƒƒã‚¯
            const directions = [{x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}];
            
            directions.forEach(dir => {
                for (let i = 1; i <= 3; i++) {
                    const x = bomb.x + (dir.x * i);
                    const y = bomb.y + (dir.y * i);
                    
                    if (x < 0 || x >= COLS || y < 0 || y >= ROWS) break;
                    if (gameMap[y][x] === 1) break; // å›ºå®šå£ã§åœæ­¢
                    
                    explosionCells.push({x: x, y: y});
                    
                    if (gameMap[y][x] === 2) {
                        gameMap[y][x] = 0; // ç ´å£Šå¯èƒ½å£ã‚’ç ´å£Š
                        break;
                    }
                }
            });
            
            // çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
            gameState.explosions.push({
                cells: explosionCells,
                startTime: Date.now(),
                duration: 500
            });
            
            // ãƒ€ãƒ¡ãƒ¼ã‚¸åˆ¤å®š
            explosionCells.forEach(cell => {
                if (cell.x === player.x && cell.y === player.y) {
                    gameState.playerHealth--;
                }
                if (cell.x === ai.x && cell.y === ai.y) {
                    gameState.aiHealth--;
                }
            });
            
            updateHealthDisplay();
            
            // ã‚²ãƒ¼ãƒ çµ‚äº†ãƒã‚§ãƒƒã‚¯
            if (gameState.playerHealth <= 0 || gameState.aiHealth <= 0) {
                endGame();
            }
        }

        function updateExplosions() {
            const currentTime = Date.now();
            
            for (let i = gameState.explosions.length - 1; i >= 0; i--) {
                const explosion = gameState.explosions[i];
                if (currentTime - explosion.startTime >= explosion.duration) {
                    gameState.explosions.splice(i, 1);
                }
            }
        }

        function endGame() {
            gameState.isPlaying = false;
            let winner;
            if (gameState.playerHealth <= 0 && gameState.aiHealth <= 0) {
                winner = 'å¼•ãåˆ†ã‘';
            } else if (gameState.playerHealth <= 0) {
                winner = 'ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã®å‹åˆ©';
            } else {
                winner = 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©';
            }
            
            document.getElementById('winnerText').textContent = `ğŸ† ${winner}ï¼`;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            startGame();
        }

        function draw() {
            // èƒŒæ™¯ã‚’ã‚¯ãƒªã‚¢
            ctx.fillStyle = '#34495e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ãƒãƒƒãƒ—ã‚’æç”»
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    const cellX = x * GRID_SIZE;
                    const cellY = y * GRID_SIZE;
                    
                    if (gameMap[y][x] === 1) {
                        // å›ºå®šå£
                        ctx.fillStyle = '#2c3e50';
                        ctx.fillRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                        ctx.strokeStyle = '#1a252f';
                        ctx.strokeRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                    } else if (gameMap[y][x] === 2) {
                        // ç ´å£Šå¯èƒ½å£
                        ctx.fillStyle = '#95a5a6';
                        ctx.fillRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                        ctx.strokeStyle = '#7f8c8d';
                        ctx.strokeRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                    }
                }
            }

            // çˆ†ç™ºã‚’æç”»ï¼ˆãƒªã‚¢ãƒ«ãªç‚ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
            gameState.explosions.forEach(explosion => {
                const elapsed = Date.now() - explosion.startTime;
                const progress = elapsed / explosion.duration;
                
                explosion.cells.forEach(cell => {
                    const cellX = cell.x * GRID_SIZE;
                    const cellY = cell.y * GRID_SIZE;
                    
                    // ç‚ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
                    const gradient = ctx.createRadialGradient(
                        cellX + GRID_SIZE/2, cellY + GRID_SIZE/2, 0,
                        cellX + GRID_SIZE/2, cellY + GRID_SIZE/2, GRID_SIZE/2
                    );
                    
                    // æ™‚é–“çµŒéã§ç‚ã®è‰²ãŒå¤‰åŒ–
                    const intensity = 1 - progress;
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity * 0.8})`);
                    gradient.addColorStop(0.3, `rgba(255, 200, 0, ${intensity})`);
                    gradient.addColorStop(0.6, `rgba(255, 100, 0, ${intensity * 0.9})`);
                    gradient.addColorStop(1, `rgba(200, 0, 0, ${intensity * 0.7})`);
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                    
                    // ç‚ã®æºã‚‰ã‚ãåŠ¹æœ
                    if (Math.random() < 0.3) {
                        const flickerGradient = ctx.createRadialGradient(
                            cellX + GRID_SIZE/2 + (Math.random() - 0.5) * 10,
                            cellY + GRID_SIZE/2 + (Math.random() - 0.5) * 10, 0,
                            cellX + GRID_SIZE/2, cellY + GRID_SIZE/2, GRID_SIZE/3
                        );
                        flickerGradient.addColorStop(0, `rgba(255, 255, 100, ${intensity * 0.6})`);
                        flickerGradient.addColorStop(1, 'rgba(255, 255, 100, 0)');
                        ctx.fillStyle = flickerGradient;
                        ctx.fillRect(cellX, cellY, GRID_SIZE, GRID_SIZE);
                    }
                });
            });

            // çˆ†å¼¾ã‚’æç”»
            gameState.bombs.forEach(bomb => {
                const elapsed = Date.now() - bomb.startTime;
                const flashRate = Math.max(100, 500 - elapsed);
                const isFlashing = Math.floor(elapsed / flashRate) % 2 === 0;
                
                ctx.fillStyle = isFlashing ? '#e74c3c' : '#c0392b';
                ctx.fillRect(bomb.x * GRID_SIZE + 2, bomb.y * GRID_SIZE + 2, GRID_SIZE - 4, GRID_SIZE - 4);
                
                // ã‚¿ã‚¤ãƒãƒ¼è¡¨ç¤º
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                const timeLeft = Math.ceil((bomb.timer - elapsed) / 1000);
                ctx.fillText(timeLeft, bomb.x * GRID_SIZE + GRID_SIZE/2, bomb.y * GRID_SIZE + GRID_SIZE/2 + 4);
            });

            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³ã‚’æç”»
            const playerX = player.x * GRID_SIZE;
            const playerY = player.y * GRID_SIZE;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼èƒŒæ™¯å††
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(playerX + GRID_SIZE/2, playerY + GRID_SIZE/2, GRID_SIZE/2 - 2, 0, Math.PI * 2);
            ctx.fill();
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼çµµæ–‡å­—
            ctx.font = `${GRID_SIZE - 8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = 'white';
            ctx.fillText('ğŸ˜Š', playerX + GRID_SIZE/2, playerY + GRID_SIZE/2);
            
            // AIã‚¢ã‚¤ã‚³ãƒ³ã‚’æç”»
            const aiX = ai.x * GRID_SIZE;
            const aiY = ai.y * GRID_SIZE;
            
            // AIèƒŒæ™¯å††
            ctx.fillStyle = ai.color;
            ctx.beginPath();
            ctx.arc(aiX + GRID_SIZE/2, aiY + GRID_SIZE/2, GRID_SIZE/2 - 2, 0, Math.PI * 2);
            ctx.fill();
            
            // AIçµµæ–‡å­—
            ctx.fillStyle = 'white';
            ctx.fillText('ğŸ¤–', aiX + GRID_SIZE/2, aiY + GRID_SIZE/2);

            // ã‚²ãƒ¼ãƒ é–‹å§‹å¾…ã¡
            if (!gameState.isPlaying && gameState.playerHealth === 3 && gameState.aiHealth === 3) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Enterã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ é–‹å§‹', canvas.width / 2, canvas.height / 2);
            }
        }

        function gameLoop() {
            if (gameState.isPlaying) {
                updatePlayer();
                updateAI();
                updateBombs();
                updateExplosions();
            }
            draw();
            
            if (gameState.isPlaying) {
                requestAnimationFrame(gameLoop);
            }
        }

        // åˆæœŸæç”»
        initializeMap();
        draw();
    </script>
</body>
</html>